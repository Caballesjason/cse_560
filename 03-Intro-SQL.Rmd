---
site: "bookdown::bookdown_site"
documentclass: "book"
output:
  bookdown::bs4_book: "default"
---

# Introducion to SQL
## Partition of the SQL language
The current standard for SQL is __SQL-99__.  There are two aspects to the SQL language:    
1. The __Data Definition Language (DDL)__ to declare database schemas    
2. The __Data Manipulation Language (DML)__ sub-language for querying/modifying databases 

### Why SQL?
SQL is a high level language.  When using SQL, we simply ask “what to do” rather than “how to do it.”.  This allows to disregard complex data manipulation and DBMS utilize _query optimizations_ to optimize queries.

## Relations in SQL
SQL makes a distinction between three kinds of relations:   
1. __Stored relations__, which are called __tables__    
2. __Views__, which are relations designed by some computation.  These relations are not stored in memory, but constructed when needed   
3. __Temporary Tables__ which are constructed by the SQL language processor when executing queries and data modifications.  These relations are not stored in memory and discarded when no longer used.   

Before we dive into operations in SQL, we will go over the order of execution for any query.  The order of execution for any query is as follows

1. `FROM`
2. `JOIN`
3. `WHERE`
4. `GROUP BY`
5. `HAVING`
6. `SELECT`
7. `ORDER BY`
8. `LIMIT`

This is also the meaning of a _single relation query_

To declare a schema for a stored relation, do the following

```{sql, eval=FALSE}
CREATE TABLE MovieStar( -- CREATE TABLE Initializes the create of the MovieStar schema
  name CHAR(30)         -- For every attribute, declare its data type
  ,address CHAR(30)
  ,gender char(1)
  ,birthdate date
PRIMARY KEY (name)  -- Assign the name attribute as the primary key for the schema
);
```


## Foreign Keys
A foreign key is designed to create a relationship between two or more relations utilizing attributes that are similar to each other.  We say "similar"because  these attributes can have different names for each relation.  Foreign keys reference primary keys or "unique" attributes from other relations.

The table that contains a foreign key is referencing an attribute from another table.  The relations with the foreign key is the _referencing table_ while the relation that the referencing relation is referring to is known as the _referenced table_.  There is no constraint to how many foreign keys a table may have, as long as they define a relationship to another relation.

There are two ways to declare a column to be a foreign key.  Both use the keyword `REFERENCE`.

```{sql Foreign Key Syntax, eval=FALSE}
CREATE TABLE Student(
  id VARCHAR(5)
  ,name VARCHAR(20) NOT NULL
  ,dept_name VARCHAR(20)
  ,tot_cred NUMERIC(3, 0) -- 3 indicates the total # of digits allowed for the float while 0 indicates the number of digits allowed after the decimal point
  ,PRIMARY KEY (id)
  ,FOREIGN KEY (dept_name) REFERENCES department
);

-- This needs to be reviewed
```

## SELECT, FROM, WHERE Statements
- `SELECT`:  Chooses a subset of tuples
- `FROM`:  Chooses which relation to pull data from
- `WHERE`:  Choose tuples based on conditions

## Relation Schema Modification
### Deleting Relations
This is how we can delete relations

```{sql Deleting Tables, eval=FALSE}
DELETE -- Some Table

-- We can also do this
DELETE FROM -- Some Table
```

### Altering Tables
This is how we alter tables

```{sql Altering tables, eval=FALSE}
-- Adding a attribute "surname" to Instructor1 --
ALTER TABLE Instructor1 ADD surname CHAR(100);

-- Dropping surname from Instructor1 --
ALTER TABLE Instructor1 DROP surname;

-- Renaming department attribute to dept from Instructor
ALTER TABLE Instuctor RENAME COLUMN Department TO dept;

-- Renaming relation Instructor to "Teacher"
ALTER TABLE Instuctor RENAME TO Teacher;
```

\

## SELECT
`SELECT` chooses the attributes that you want in your query.  It corresponds to the projection operator $\pi_{C}{(R)}$.  In SQL, names of relations and attributes are not case sensitive.  In practice, any keywords should be capitalized.

For example:

```{sql SELECT Example, connection=conn, max.print=5}
-- Using the SELECT clause to grab the name attribute! --
SELECT name
FROM instructor;
```

A short handed way to project all attributes from a relation is by using an asterisk `*`.

```{sql SELECT * Example, eval=F}
-- Return all attributes for all tuples with manf=Anheuser-Busch
SELECT *
FROM Beers
WHERE manf='Anheuser-Busch';
```

SQL is an interpreted language (like python).  Therefore code gets executed line by line!  Likewise each tuple in a relation gets evaluated one at a time to see if it should be returned in the output relation.

For example, suppose we have the following query:

```{sql Operational Semenatics, eval=FALSE}
-- Grabbing the 'name' attribute from Beers --
SELECT name
FROM Beers
WHERE manf='Anheuser-Busch';
```

For every tuple, the name component is being evaluated.  If the component has the value "Anheuser-Busch", then tuple is returned in the new relation!

![Operation Semantics](images/03-OperationSemantics.png){width=100%}

We can also add new attributes using the attributes from the relation we are retrieving data from.

```{sql Custom Attributes, eval=F}
SELECT bar,
  ,beer
  ,price*114 AS PriceInYen
FROM Sells;
```

### DISTINCT/ALL
SQL allows for duplicate tuples, therefore, to return strictly unique tuples, you can use the `DISTINCT` clause.

For example:

```{sql DISTINCT Example,  connection=conn, max.print=5}
-- Grabbing the unique department names from Instructor --
SELECT DISTINCT dept_name
FROM Instructor;
```

In contrast, the SQL keyword `ALL` allows you to explicitly state that duplicates should not be removed.

```{sql ALL Example,  connection=conn, max.print=5}
-- Grabbing all instances of dept_name attribute from Instructor --
SELECT ALL dept_name
FROM Instructor;
```

The rest of the examples in this section will use the following relations

$$
Beers(\underline{name}, manf) \\
Bars (\underline{name}, addr, license) \\
Drinkers(\underline{name}, addr, phone) \\
Likes(\underline{drinker}, {beer}) \\
Sells(\underline{bar}, {beer}, price) \\
Frequents(\underline{drinker}, {bar})
\\~\\
\text{Note: underlined attributes indicate keys}
$$
<!--- Must review this example --->
Here is another example using `All`.

Using `Frequents` and `Likes`, list all drinks who go to a higher number of different bars than they like different beers and does so as many times as the difference of those counts.

```{sql ALL Example 2, eval=FALSE}
SELECT drinker
FROM Frequents

EXCEPT ALL

SELECT drinker
FROM Likes;
```

In this query, `EXCEPT` returns distinct rows from the top query that are not in the bottom query.  

Here is another example using `DISTINCT`.
From `Sells`, find the different prices charged for beers

```{sql DISTINCT example 2, eval=F}
SELECT DISTINCT price
FROM Sells;
```

If distinct was not used, then your output relation would see duplicates of prices!

### SELECT and Literals
You can assign relations to contain only literals (any primative data type).

For example:

```{sql SELECT Literal, connection=conn}
-- Selecting a literal --
SELECT '437' AS 'Literal';
```

Here we have returned a $1 \times 1$ relation with an attribute name `Literal` with a value of "437".

If we add `FROM`, to the query, we will have an $n\times{1}$ relation for $n$ tuples in the relation we are referencing in `FROM`.

```{sql SELECT Literal Example 2, connection=conn, max.print=5}
-- Selecting a literal with FROM --
SELECT '437' AS 'Literal'
FROM instructor;
```

## WHERE


## FROM


## RENAME


## Patterns
### Like


## Null


## Multiple Relational Queries


## Joining Two Relations


## Explicit Tuple-Variables


## Self-Joins


## Subqueries


## Set Operations


## Single-Tuple Subquery


## Query + Subquery


## Between


## In


## Exists


## Any


## Except


## Union, Intersection, Difference


## Recursive Queries


## Bag Semantics

<!--- 
ADD THE FOLLOWING AFTER ORGANZING NOTES
## Controlling Duplicate Elimination
### Data Types
The following are primitive data types that are supported by SQL    

#### Character Strings
They can be of fixed or variable length.  To type a fixed length character string, use `CHAR(n)` for some length $n$.  To create a variable length character string, use `VARCHAR(n)` for some length $n$.  If a component of a tuple with a domain of `CHAR(n)` is given and the length of the component is less than $n$, the component is padded with white space. 

#### Bit Strings
Bit strings can be of fixed or varying length. This data type is analogous to character strings, but their values are strings of bits rather than characters.

#### BOOLEANs
Booleans denote an attribute whose value is logical.  The possible values that a boolean can take are __TRUE, FALSE, UNKNOWN__.

#### INTs
Ints or (Integers) denote some integer value.  `SHORTINT` is also an int but is may have less bits.

#### Floating-Point Numbers
Floating points are denoted by `FLOAT` or `REAL`.  If you would like higher precision with floats, use `DOUBLE PRECISION`.  Like character strings, floats can be of fixed decimal length.  You can declare decimal length but calling `DECIMAL(n, d)` where $n$ is the total number of digits allowed for the float nad $d$ is the number of digits passed the decimal. 

#### Dates and Times
Dates and times are declared using `DATE` and `TIME` respectively. Dates and times are a special form of character strings.  Adding a string after the `DATE` declaration specifies the format of the date.  For example `DATE '1948-05-14'` creates a date value with the form "YYYY-MM-DD".  The same can be done with time.  For example `TIME '15:00:02.5'` specifies that you want to represent time with the format "HH:MM:SS" with the attachment of milliseconds. 

The follow is a simple example of a Relation Schema declaration

```{sql, eval=FALSE}
CREATE TABLE Movies(
  title CHAR(100) -- Character string with 100 characters
  ,year INT
  ,lengh INT
  ,genre CHAR(10)
  ,studioName CHAR(30)
  ,producerC# INT
);
```

### Modifying Relation Schemas
To delete or "drop" a table from a database, execute the following    

```{sql, eval=FALSE}
DROP TABLE -- SOME TABLE --;
```

When dropping at able, the table no longer exists in the database schema.  To modify and existing table, use the `ALTER` keyword   

```{sql, eval=FALSE}
---- Modifying a table to add a new attribute to its schema ----
ALTER TABLE -- SOME TABLE -- ADD -- SOME ATTRIBUTE -- CHAR(16); 

---- Modifying a table to remove an attribute from its schema ----
ALTER TABLE -- SOME TABLE -- DROP -- SOME ATTRIBUTE IN SCHEMA --; 
```

### Default Values
When adding a new attribute to a relation's schema, all tuples require some value for that attribute.  Database systems will default that value to `NULL`, but what if you want a specific value for it default to?  What if data is uploaded randomly and not all tuples have values for each component?   In this case we can use the `DEFAULT` keyword to add a specific value instead using `NULL`.

```{sql, eval=FALSE}
---- Creating attributes and adding a default value when no data is made available ----
gender CHAR(1) DEFAULT '?'
name VARCHAR(10) DEFAULT 'No Name :('
```

#### Declaring Keys
There are two ways to assign a set of attributes to be a key.  Keys are defined in the declaration of the database schema, i.e. the  `CREATE TABLE` statement.

Use `PRIMARY KEY` or `UNIQUE` to declare a set of attributes to be a key.  Remember, that keys must always be unique for each tuple.  The difference between `PRIMARY KEY` and `UNIQUE` is that components a tuple are allowed to have `NULL` as a value when using `UNIQUE`.  On the other hand, using `PRIMARY KEY` does not allow `NULL` to be in a key.

```{sql, eval=FALSE}
---- Assigning name as a primary key ---
CREATE TABLE MovieStar(
  name CHAR(30) PRIMARY KEY
  ,address VARCHAR(255)
  ,gender CHAR(1)
  ,birthdate DATE
);

---- You can assign keys after declaring all attributes as well! ----
CREATE TABLE MovieStar(
  name CHAR(30)
  ,address VARCHAR(255)
  ,gender CHAR(1)
  ,birthdate DATE
  PRIMARY KEY (name)
);
```

## Constraints

--->
