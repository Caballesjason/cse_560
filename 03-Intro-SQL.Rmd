---
site: "bookdown::bookdown_site"
documentclass: "book"
output:
  bookdown::bs4_book: "default"
---

# Introducion to SQL
## Partition of the SQL language
The current standard for SQL is __SQL-99__.  There are two aspects to the SQL language:    
1. The __Data Definition Language (DDL)__ to declare database schemas    
2. The __Data Manipulation Language (DML)__ sub-language for querying/modifying databases 

### Why SQL?
SQL is a high level language.  When using SQL, we simply ask “what to do” rather than “how to do it.”.  This allows to disregard complex data manipulation and DBMS utilize _query optimizations_ to optimize queries.

## Relations in SQL
SQL makes a distinction between three kinds of relations:   
1. __Stored relations__, which are called __tables__    
2. __Views__, which are relations designed by some computation.  These relations are not stored in memory, but constructed when needed   
3. __Temporary Tables__ which are constructed by the SQL language processor when executing queries and data modifications.  These relations are not stored in memory and discarded when no longer used.   

Before we dive into operations in SQL, we will go over the order of execution for any query.  The order of execution for any query is as follows

1. `FROM`
2. `JOIN`
3. `WHERE`
4. `GROUP BY`
5. `HAVING`
6. `SELECT`
7. `ORDER BY`
8. `LIMIT`

To declare a schema for a stored relation, do the following

```{sql, eval=FALSE}
CREATE TABLE MovieStar( -- CREATE TABLE Initializes the create of the MovieStar schema
  name CHAR(30)         -- For every attribute, declare its data type
  ,address CHAR(30)
  ,gender char(1)
  ,birthdate date
PRIMARY KEY (name)  -- Assign the name attribute as the primary key for the schema
);
```


## Foreign Keys
A foreign key is designed to create a relationship between two or more relations utilizing attributes that are similar to each other.  We say "similar"because  these attributes can have different names for each relation.  Foreign keys reference primary keys or "unique" attributes from other relations.

The table that contains a foreign key is referencing an attribute from another table.  The relations with the foreign key is the _referencing table_ while the relation that the referencing relation is referring to is known as the _referenced table_.  There is no constraint to how many foreign keys a table may have, as long as they define a relationship to another relation.

There are two ways to declare a column to be a foreign key.  Both use the keyword `REFERENCE`.

```{sql Foreign Key Syntax, eval=FALSE}
CREATE TABLE Student(
  id VARCHAR(5)
  ,name VARCHAR(20) NOT NULL
  ,dept_name VARCHAR(20)
  ,tot_cred NUMERIC(3, 0) -- 3 indicates the total # of digits allowed for the float while 0 indicates the number of digits allowed after the decimal point
  ,PRIMARY KEY (id)
  ,FOREIGN KEY (dept_name) REFERENCES department
);

-- This needs to be reviewed
```

## SELECT, FROM, WHERE Statements
- `SELECT`:  Chooses a subset of tuples
- `FROM`:  Chooses which relation to pull data from
- `WHERE`:  Choose tuples based on conditions

## Relation Schema Modification
### Deleting Relations
This is how we can delete relations

```{sql Deleting Tables, eval=FALSE}
DELETE -- Some Table

-- We can also do this
DELETE FROM -- Some Table
```

### Altering Tables
This is how we alter tables

```{sql Altering tables, eval=FALSE}
-- Adding a attribute "surname" to Instructor1 --
ALTER TABLE Instructor1 ADD surname CHAR(100);

-- Dropping surname from Instructor1 --
ALTER TABLE Instructor1 DROP surname;

-- Renaming department attribute to dept from Instructor
ALTER TABLE Instuctor RENAME COLUMN Department TO dept;

-- Renaming relation Instructor to "Teacher"
ALTER TABLE Instuctor RENAME TO Teacher;
```

## SELECT Cause


## DISTINCT


## WHERE


## FROM


## RENAME


## Patterns
### Like


## Null


## Multiple Relational Queries


## Joining Two Relations


## Explicit Tuple-Variables


## Self-Joins


## Subqueries


## Set Operations


## Single-Tuple Subquery


## Query + Subquery


## Between


## In


## Exists


## Any


## Except


## Union, Intersection, Difference


## Recursive Queries


## Bag Semantics

<!--- 
ADD THE FOLLOWING AFTER ORGANZING NOTES
## Controlling Duplicate Elimination
### Data Types
The following are primitive data types that are supported by SQL    

#### Character Strings
They can be of fixed or variable length.  To type a fixed length character string, use `CHAR(n)` for some length $n$.  To create a variable length character string, use `VARCHAR(n)` for some length $n$.  If a component of a tuple with a domain of `CHAR(n)` is given and the length of the component is less than $n$, the component is padded with white space. 

#### Bit Strings
Bit strings can be of fixed or varying length. This data type is analogous to character strings, but their values are strings of bits rather than characters.

#### BOOLEANs
Booleans denote an attribute whose value is logical.  The possible values that a boolean can take are __TRUE, FALSE, UNKNOWN__.

#### INTs
Ints or (Integers) denote some integer value.  `SHORTINT` is also an int but is may have less bits.

#### Floating-Point Numbers
Floating points are denoted by `FLOAT` or `REAL`.  If you would like higher precision with floats, use `DOUBLE PRECISION`.  Like character strings, floats can be of fixed decimal length.  You can declare decimal length but calling `DECIMAL(n, d)` where $n$ is the total number of digits allowed for the float nad $d$ is the number of digits passed the decimal. 

#### Dates and Times
Dates and times are declared using `DATE` and `TIME` respectively. Dates and times are a special form of character strings.  Adding a string after the `DATE` declaration specifies the format of the date.  For example `DATE '1948-05-14'` creates a date value with the form "YYYY-MM-DD".  The same can be done with time.  For example `TIME '15:00:02.5'` specifies that you want to represent time with the format "HH:MM:SS" with the attachment of milliseconds. 

The follow is a simple example of a Relation Schema declaration

```{sql, eval=FALSE}
CREATE TABLE Movies(
  title CHAR(100) -- Character string with 100 characters
  ,year INT
  ,lengh INT
  ,genre CHAR(10)
  ,studioName CHAR(30)
  ,producerC# INT
);
```

### Modifying Relation Schemas
To delete or "drop" a table from a database, execute the following    

```{sql, eval=FALSE}
DROP TABLE -- SOME TABLE --;
```

When dropping at able, the table no longer exists in the database schema.  To modify and existing table, use the `ALTER` keyword   

```{sql, eval=FALSE}
---- Modifying a table to add a new attribute to its schema ----
ALTER TABLE -- SOME TABLE -- ADD -- SOME ATTRIBUTE -- CHAR(16); 

---- Modifying a table to remove an attribute from its schema ----
ALTER TABLE -- SOME TABLE -- DROP -- SOME ATTRIBUTE IN SCHEMA --; 
```

### Default Values
When adding a new attribute to a relation's schema, all tuples require some value for that attribute.  Database systems will default that value to `NULL`, but what if you want a specific value for it default to?  What if data is uploaded randomly and not all tuples have values for each component?   In this case we can use the `DEFAULT` keyword to add a specific value instead using `NULL`.

```{sql, eval=FALSE}
---- Creating attributes and adding a default value when no data is made available ----
gender CHAR(1) DEFAULT '?'
name VARCHAR(10) DEFAULT 'No Name :('
```

#### Declaring Keys
There are two ways to assign a set of attributes to be a key.  Keys are defined in the declaration of the database schema, i.e. the  `CREATE TABLE` statement.

Use `PRIMARY KEY` or `UNIQUE` to declare a set of attributes to be a key.  Remember, that keys must always be unique for each tuple.  The difference between `PRIMARY KEY` and `UNIQUE` is that components a tuple are allowed to have `NULL` as a value when using `UNIQUE`.  On the other hand, using `PRIMARY KEY` does not allow `NULL` to be in a key.

```{sql, eval=FALSE}
---- Assigning name as a primary key ---
CREATE TABLE MovieStar(
  name CHAR(30) PRIMARY KEY
  ,address VARCHAR(255)
  ,gender CHAR(1)
  ,birthdate DATE
);

---- You can assign keys after declaring all attributes as well! ----
CREATE TABLE MovieStar(
  name CHAR(30)
  ,address VARCHAR(255)
  ,gender CHAR(1)
  ,birthdate DATE
  PRIMARY KEY (name)
);
```

## Constraints

--->
